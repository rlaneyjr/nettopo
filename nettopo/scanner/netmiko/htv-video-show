#!/usr/bin/env python
"""Return output from single show cmd using Netmiko."""
from __future__ import print_function
from __future__ import unicode_literals

import argparse
import sys
import os
import subprocess
import threading
try:
    from Queue import Queue
except ImportError:
    from queue import Queue
from datetime import datetime
from getpass import getpass

from netmiko import ConnectHandler
from netmiko.utilities import load_devices, display_inventory
from netmiko.utilities import obtain_all_devices
from netmiko.utilities import obtain_netmiko_filename, write_tmp_file, ensure_dir_exists
from netmiko.utilities import find_netmiko_dir
from netmiko.utilities import SHOW_RUN_MAPPER

NETMIKO_BASE_DIR = './tmp'
ERROR_PATTERN = "%%%failed%%%"
__version__ = '0.1.0'


def ssh_conn(device_name, a_device, command, output_q):
    try:
        net_connect = ConnectHandler(**a_device)
        net_connect.enable()
        output = net_connect.send_command_expect(command)
        net_connect.disconnect()
    except Exception:
        output = ERROR_PATTERN
    output_q.put({device_name: output})


def parse_arguments(args):
    """Parse command-line arguments."""
    description = "Return output from single show cmd using Netmiko (defaults to running-config)"
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument("--username", help="Username", action="store", type=str)
    parser.add_argument("--password", help="Password", action="store_true")
    parser.add_argument("--secret", help="Enable Secret", action="store_true")
    parser.add_argument("--list-devices", help="List devices from inventory", action="store_true")
    parser.add_argument("--display-runtime", help="Display program runtime", action="store_true")
    parser.add_argument("--version", help="Display version", action="store_true")
    cli_args = parser.parse_args(args)
    return cli_args


def main(args):
    my_devices = load_devices(file_name='htv_video.yml')
    start_time = datetime.now()
    cli_args = parse_arguments(args)

    cli_username = cli_args.username if cli_args.username else None
    cli_password = getpass() if cli_args.password else None
    cli_secret = getpass("Enable secret: ") if cli_args.secret else None

    version = cli_args.version
    if version:
        print("htv-video-show v{}".format(__version__))
        return 0
    list_devices = cli_args.list_devices
    if list_devices:
        display_inventory(my_devices)
        device_group = obtain_all_devices(my_devices)
        return 0

    output_q = Queue()
    device_group = obtain_all_devices(my_devices)

    # Retrieve output from devices
    my_files = []
    failed_devices = []
    for device_name, a_device in device_group.items():
        if cli_username:
            a_device['username'] = cli_username
        if cli_password:
            a_device['password'] = cli_password
        if cli_secret:
            a_device['secret'] = cli_secret
        try:
            command = a_device.pop('cmd')
        except KeyError:
            print("You must provide a cmd variable in the device file")
            return 0
        my_thread = threading.Thread(target=ssh_conn, args=(device_name, a_device,
                                                            command, output_q))
        my_thread.start()
    # Make sure all threads have finished
    main_thread = threading.currentThread()
    for some_thread in threading.enumerate():
        if some_thread != main_thread:
            some_thread.join()
    # Write files
    while not output_q.empty():
        my_dict = output_q.get()
        for dev, out in my_dict.items():
            print("{}:\n{}\n".format(dev, out))
        netmiko_base_dir, netmiko_full_dir = find_netmiko_dir()
        ensure_dir_exists(netmiko_base_dir)
        ensure_dir_exists(netmiko_full_dir)
        for device_name, output in my_dict.items():
            file_name = write_tmp_file(device_name, output)
            if ERROR_PATTERN not in output:
                my_files.append(file_name)
            else:
                failed_devices.append(device_name)

    if cli_args.display_runtime:
        print("Total time: {0}".format(datetime.now() - start_time))

    if failed_devices:
        print("\n")
        print("-" * 20)
        print("Failed devices:")
        failed_devices.sort()
        for device_name in failed_devices:
            print("  {}".format(device_name))
        print()
    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
